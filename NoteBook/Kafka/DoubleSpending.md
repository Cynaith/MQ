- 每条消息都有一个offset，可理解为消息的序号。
- 消费者从kafka消费时，是按照顺序去消费。
- 消费之后，消费者会提交offset至kafka，告诉kafka已经消费到offset=xxx的这条数据。
- zookeeper里面就记录了消费者当前消费到了offset=xxx的那条消息。
- 假设此时消费者被重启，重启之后，消费者会找kafka把上次消费到的那个地方后面的数据继续传递过来。
- 注：消费者不是消费一条数据就立马提交offset的，而是定时定期提交一次offset
- 幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用
    - 一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。
- 如何保证消息队列消费的幂等性
    - 如果是写redis，则没问题，每次都是set，天然幂等性。
    - 生产者发送每条数据的时候，里面加一个全局的id，类似订单id之类的东西，然后消费到了之后，先根据这个id去（比如）redis里查一下，查一下是否之前消费过？如果没有消费过，就处理，然后这个id写redis。如果消费过了，就别处理了。
    - 基于数据库的唯一键来保证重复数据不会重复插入多条。重复数据只会插入报错，不会导致数据库中出现脏数据。
    - 还需根据具体的业务来看。